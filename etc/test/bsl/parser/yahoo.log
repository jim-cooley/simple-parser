

test:
any:{close > close.sma10, close.sma10 > close.sma20} | signal | mul(_, -atr.plus1) | trades | print
# trades[> 0] | buys | tail | print

quotes = yahoo( symbols='portfolio.csv', span=-5y )
(open, close, high, low, atr, volume, first, last) = quotes

atr | delay(_, 1d) | atr.plus1 | print

close | describe | print

close | sma(_, 10) | close.sma10 | print
close | sma(_, 20) | close.sma20 | print

close | columns(_, 'AAPL') | delta(_, 1) | signal | print

print("clipbefore")
close | delta | signal | clipbefore(_, 1, 0, 1, 0) | print

close.sma10 > close.sma20 | signal | mul(_, -atr.plus1) | trades | print

print("compound")
any:{close > close.sma10, close.sma10 > close.sma20} | signal | mul(_, -atr.plus1) | trades | print
# close > close.sma10 or close.sma10 > close.sma20 | signal | mul(_, -atr.plus1) | trades | print


print("trading")
trades > 0 | print
trades > 0 | buys | tail | print
trades < 0 | sells | head | print

print("trim")
close | delta | signal | trim | print

trades | cumsum | results | print

results | tail(_, 20) | print


print('buys =', buys)
print('sells =', sells)

close | write(_, 'quotes.json', format='json')


tree1:  any:{close > close.sma10, close.sma10 > close.sma20} | signal | mul(_, -atr.plus1) | trades | print
    1  : Flow{TK.CHAIN, '|' len=5}
    2  :     UnaryOp(TK.ANY, 'any')
    3  :         Generate(TK.SET, len=2)
    4  :             BinOp(TK.GTR, '>')
    5  :                 Get(TK.IDENT, 'close')
    6  :                 PropRef(TK.REF: close . Get(TK.IDENT, 'sma10'))
    7  :                     Get(TK.IDENT, 'close')
    8  :                     Get(TK.IDENT, 'sma10')
    9  :             BinOp(TK.GTR, '>')
   10  :                 PropRef(TK.REF: close . Get(TK.IDENT, 'sma10'))
   11  :                     Get(TK.IDENT, 'close')
   12  :                     Get(TK.IDENT, 'sma10')
   13  :                 PropRef(TK.REF: close . Get(TK.IDENT, 'sma20'))
   14  :                     Get(TK.IDENT, 'close')
   15  :                     Get(TK.IDENT, 'sma20')
   16  :     Ref(TK.IDENT, 'signal')
   17  :     FnCall('mul')
   18  :         Ref(TK.IDENT, 'mul')
   19  :         Generate(TK.LIST, len=2)
   20  :             Ref(TK.ANON, '_')
   21  :             UnaryOp(TK.NEG, '-')
   22  :                 PropRef(TK.REF: atr . Ref(TK.IDENT, 'plus1'))
   23  :                     Ref(TK.IDENT, 'atr')
   24  :                     Ref(TK.IDENT, 'plus1')
   25  :     Ref(TK.IDENT, 'trades')
   26  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
   27  :         Ref(TK.IDENT, 'print')

tree2:  quotes = yahoo( symbols='portfolio.csv', span=-5y )
    1  : Define(TK.DEFINE: quotes = FnCall(TK.FUNCTION, 'yahoo'))
    2  :     Ref(TK.IDENT, 'quotes')
    3  :     FnCall('yahoo')
    4  :         Get(TK.IDENT, 'yahoo')
    5  :         Generate(TK.NAMEDTUPLE, len=2)
    6  :             Define(TK.DEFINE: symbols = portfolio.csv)
    7  :                 Ref(TK.IDENT, 'symbols')
    8  :                 Str(TK.STR, 'portfolio.csv')
    9  :             Define(TK.DEFINE: span = UnaryOp(TK.NEG, '-'))
   10  :                 Ref(TK.IDENT, 'span')
   11  :                 UnaryOp(TK.NEG, '-')
   12  :                     Duration(TK.DUR, 1825 days, 0:00:00)

tree3:  (open, close, high, low, atr, volume, first, last) = quotes
    1  : Define(TK.DEFINE: [count=7]:tup = Get(TK.IDENT, 'quotes'))
    2  :     Generate(TK.TUPLE, len=8)
    3  :         Ref(TK.IDENT, 'open')
    4  :         Ref(TK.IDENT, 'close')
    5  :         Ref(TK.IDENT, 'high')
    6  :         Ref(TK.IDENT, 'low')
    7  :         Ref(TK.IDENT, 'atr')
    8  :         Ref(TK.IDENT, 'volume')
    9  :         Ref(TK.IDENT, 'first')
   10  :         Ref(TK.IDENT, 'last')
   11  :     Get(TK.IDENT, 'quotes')

tree4:  atr | delay(_, 1d) | atr.plus1 | print
    1  : Flow{TK.CHAIN, '|' len=4}
    2  :     Get(TK.IDENT, 'atr')
    3  :     FnCall('delay')
    4  :         Ref(TK.IDENT, 'delay')
    5  :         Generate(TK.LIST, len=2)
    6  :             Ref(TK.ANON, '_')
    7  :             Duration(TK.DUR, 1 day, 0:00:00)
    8  :     PropRef(TK.REF: atr . Ref(TK.IDENT, 'plus1'))
    9  :         Ref(TK.IDENT, 'atr')
   10  :         Ref(TK.IDENT, 'plus1')
   11  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
   12  :         Ref(TK.IDENT, 'print')

tree5:  close | describe | print
    1  : Flow{TK.CHAIN, '|' len=3}
    2  :     Get(TK.IDENT, 'close')
    3  :     Ref(TK.IDENT, 'describe')
    4  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
    5  :         Ref(TK.IDENT, 'print')

tree6:  close | sma(_, 10) | close.sma10 | print
    1  : Flow{TK.CHAIN, '|' len=4}
    2  :     Get(TK.IDENT, 'close')
    3  :     FnCall('sma')
    4  :         Ref(TK.IDENT, 'sma')
    5  :         Generate(TK.LIST, len=2)
    6  :             Ref(TK.ANON, '_')
    7  :             Int(TK.INT, 10)
    8  :     PropRef(TK.REF: close . Ref(TK.IDENT, 'sma10'))
    9  :         Ref(TK.IDENT, 'close')
   10  :         Ref(TK.IDENT, 'sma10')
   11  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
   12  :         Ref(TK.IDENT, 'print')

tree7:  close | sma(_, 20) | close.sma20 | print
    1  : Flow{TK.CHAIN, '|' len=4}
    2  :     Get(TK.IDENT, 'close')
    3  :     FnCall('sma')
    4  :         Ref(TK.IDENT, 'sma')
    5  :         Generate(TK.LIST, len=2)
    6  :             Ref(TK.ANON, '_')
    7  :             Int(TK.INT, 20)
    8  :     PropRef(TK.REF: close . Ref(TK.IDENT, 'sma20'))
    9  :         Ref(TK.IDENT, 'close')
   10  :         Ref(TK.IDENT, 'sma20')
   11  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
   12  :         Ref(TK.IDENT, 'print')

tree8:  close | columns(_, 'AAPL') | delta(_, 1) | signal | print
    1  : Flow{TK.CHAIN, '|' len=5}
    2  :     Get(TK.IDENT, 'close')
    3  :     FnCall('columns')
    4  :         Ref(TK.IDENT, 'columns')
    5  :         Generate(TK.LIST, len=2)
    6  :             Ref(TK.ANON, '_')
    7  :             Str(TK.STR, 'AAPL')
    8  :     FnCall('delta')
    9  :         Ref(TK.IDENT, 'delta')
   10  :         Generate(TK.LIST, len=2)
   11  :             Ref(TK.ANON, '_')
   12  :             Int(TK.INT, 1)
   13  :     Ref(TK.IDENT, 'signal')
   14  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
   15  :         Ref(TK.IDENT, 'print')

tree9:  any:{close > close.sma10, close.sma10 > close.sma20} | signal | mul(_, -atr.plus1) | trades | print
    1  : FnCall('print')
    2  :     Get(TK.IDENT, 'print')
    3  :     List(TK.LIST, [Str()])
    4  :         Str(TK.STR, 'clipbefore')

tree10:  close | delta | signal | clipbefore(_, 1, 0, 1, 0) | print
    1  : Flow{TK.CHAIN, '|' len=5}
    2  :     Get(TK.IDENT, 'close')
    3  :     Ref(TK.IDENT, 'delta')
    4  :     Ref(TK.IDENT, 'signal')
    5  :     FnCall('clipbefore')
    6  :         Ref(TK.IDENT, 'clipbefore')
    7  :         Generate(TK.LIST, len=5)
    8  :             Ref(TK.ANON, '_')
    9  :             Int(TK.INT, 1)
   10  :             Int(TK.INT, 0)
   11  :             Int(TK.INT, 1)
   12  :             Int(TK.INT, 0)
   13  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
   14  :         Ref(TK.IDENT, 'print')

tree11:  close.sma10 > close.sma20 | signal | mul(_, -atr.plus1) | trades | print
    1  : Flow{TK.CHAIN, '|' len=5}
    2  :     BinOp(TK.GTR, '>')
    3  :         PropRef(TK.REF: close . Get(TK.IDENT, 'sma10'))
    4  :             Get(TK.IDENT, 'close')
    5  :             Get(TK.IDENT, 'sma10')
    6  :         PropRef(TK.REF: close . Get(TK.IDENT, 'sma20'))
    7  :             Get(TK.IDENT, 'close')
    8  :             Get(TK.IDENT, 'sma20')
    9  :     Ref(TK.IDENT, 'signal')
   10  :     FnCall('mul')
   11  :         Ref(TK.IDENT, 'mul')
   12  :         Generate(TK.LIST, len=2)
   13  :             Ref(TK.ANON, '_')
   14  :             UnaryOp(TK.NEG, '-')
   15  :                 PropRef(TK.REF: atr . Ref(TK.IDENT, 'plus1'))
   16  :                     Ref(TK.IDENT, 'atr')
   17  :                     Ref(TK.IDENT, 'plus1')
   18  :     Ref(TK.IDENT, 'trades')
   19  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
   20  :         Ref(TK.IDENT, 'print')

tree12:  any:{close > close.sma10, close.sma10 > close.sma20} | signal | mul(_, -atr.plus1) | trades | print
    1  : FnCall('print')
    2  :     Get(TK.IDENT, 'print')
    3  :     List(TK.LIST, [Str()])
    4  :         Str(TK.STR, 'compound')

tree13:  any:{close > close.sma10, close.sma10 > close.sma20} | signal | mul(_, -atr.plus1) | trades | print
    1  : Flow{TK.CHAIN, '|' len=5}
    2  :     UnaryOp(TK.ANY, 'any')
    3  :         Generate(TK.SET, len=2)
    4  :             BinOp(TK.GTR, '>')
    5  :                 Get(TK.IDENT, 'close')
    6  :                 PropRef(TK.REF: close . Get(TK.IDENT, 'sma10'))
    7  :                     Get(TK.IDENT, 'close')
    8  :                     Get(TK.IDENT, 'sma10')
    9  :             BinOp(TK.GTR, '>')
   10  :                 PropRef(TK.REF: close . Get(TK.IDENT, 'sma10'))
   11  :                     Get(TK.IDENT, 'close')
   12  :                     Get(TK.IDENT, 'sma10')
   13  :                 PropRef(TK.REF: close . Get(TK.IDENT, 'sma20'))
   14  :                     Get(TK.IDENT, 'close')
   15  :                     Get(TK.IDENT, 'sma20')
   16  :     Ref(TK.IDENT, 'signal')
   17  :     FnCall('mul')
   18  :         Ref(TK.IDENT, 'mul')
   19  :         Generate(TK.LIST, len=2)
   20  :             Ref(TK.ANON, '_')
   21  :             UnaryOp(TK.NEG, '-')
   22  :                 PropRef(TK.REF: atr . Ref(TK.IDENT, 'plus1'))
   23  :                     Ref(TK.IDENT, 'atr')
   24  :                     Ref(TK.IDENT, 'plus1')
   25  :     Ref(TK.IDENT, 'trades')
   26  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
   27  :         Ref(TK.IDENT, 'print')

tree14:  any:{close > close.sma10, close.sma10 > close.sma20} | signal | mul(_, -atr.plus1) | trades | print
    1  : FnCall('print')
    2  :     Get(TK.IDENT, 'print')
    3  :     List(TK.LIST, [Str()])
    4  :         Str(TK.STR, 'trading')

tree15:  trades > 0 | print
    1  : Flow{TK.CHAIN, '|' len=2}
    2  :     BinOp(TK.GTR, '>')
    3  :         Get(TK.IDENT, 'trades')
    4  :         Int(TK.INT, 0)
    5  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
    6  :         Ref(TK.IDENT, 'print')

tree16:  trades > 0 | buys | tail | print
    1  : Flow{TK.CHAIN, '|' len=4}
    2  :     BinOp(TK.GTR, '>')
    3  :         Get(TK.IDENT, 'trades')
    4  :         Int(TK.INT, 0)
    5  :     Ref(TK.IDENT, 'buys')
    6  :     Ref(TK.IDENT, 'tail')
    7  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
    8  :         Ref(TK.IDENT, 'print')

tree17:  trades < 0 | sells | head | print
    1  : Flow{TK.CHAIN, '|' len=4}
    2  :     BinOp(TK.LESS, '<')
    3  :         Get(TK.IDENT, 'trades')
    4  :         Int(TK.INT, 0)
    5  :     Ref(TK.IDENT, 'sells')
    6  :     Ref(TK.IDENT, 'head')
    7  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
    8  :         Ref(TK.IDENT, 'print')

tree18:  any:{close > close.sma10, close.sma10 > close.sma20} | signal | mul(_, -atr.plus1) | trades | print
    1  : FnCall('print')
    2  :     Get(TK.IDENT, 'print')
    3  :     List(TK.LIST, [Str()])
    4  :         Str(TK.STR, 'trim')

tree19:  close | delta | signal | trim | print
    1  : Flow{TK.CHAIN, '|' len=5}
    2  :     Get(TK.IDENT, 'close')
    3  :     Ref(TK.IDENT, 'delta')
    4  :     Ref(TK.IDENT, 'signal')
    5  :     Ref(TK.IDENT, 'trim')
    6  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
    7  :         Ref(TK.IDENT, 'print')

tree20:  trades | cumsum | results | print
    1  : Flow{TK.CHAIN, '|' len=4}
    2  :     Get(TK.IDENT, 'trades')
    3  :     Ref(TK.IDENT, 'cumsum')
    4  :     Ref(TK.IDENT, 'results')
    5  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
    6  :         Ref(TK.IDENT, 'print')

tree21:  results | tail(_, 20) | print
    1  : Flow{TK.CHAIN, '|' len=3}
    2  :     Get(TK.IDENT, 'results')
    3  :     FnCall('tail')
    4  :         Ref(TK.IDENT, 'tail')
    5  :         Generate(TK.LIST, len=2)
    6  :             Ref(TK.ANON, '_')
    7  :             Int(TK.INT, 20)
    8  :     ApplyChainProd(TK.APPLY: None | Ref(TK.IDENT, 'print'))
    9  :         Ref(TK.IDENT, 'print')

tree22:  any:{close > close.sma10, close.sma10 > close.sma20} | signal | mul(_, -atr.plus1) | trades | print
    1  : FnCall('print')
    2  :     Get(TK.IDENT, 'print')
    3  :     Generate(TK.LIST, len=2)
    4  :         Str(TK.STR, 'buys =')
    5  :         Get(TK.IDENT, 'buys')

tree23:  any:{close > close.sma10, close.sma10 > close.sma20} | signal | mul(_, -atr.plus1) | trades | print
    1  : FnCall('print')
    2  :     Get(TK.IDENT, 'print')
    3  :     Generate(TK.LIST, len=2)
    4  :         Str(TK.STR, 'sells =')
    5  :         Get(TK.IDENT, 'sells')

tree24:  close | write(_, 'quotes.json', format='json')
    1  : Flow{TK.CHAIN, '|' len=2}
    2  :     Get(TK.IDENT, 'close')
    3  :     FnCall('write')
    4  :         Ref(TK.IDENT, 'write')
    5  :         Generate(TK.NAMEDTUPLE, len=3)
    6  :             Ref(TK.ANON, '_')
    7  :             Str(TK.STR, 'quotes.json')
    8  :             Define(TK.DEFINE: format = json)
    9  :                 Ref(TK.IDENT, 'format')
   10  :                 Str(TK.STR, 'json')
