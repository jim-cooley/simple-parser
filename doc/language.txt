# grammer notes via examples

# approaches:
# 1. equation
buy = any{ cross(close, sma(20), delay=1, threshold=0.01), cross(sma(10), sma(20), delay=1, threshold=0.01) }
buy := any{ cross(close, close.sma(20), delay=1d, threshold=0.01), cross(close.sma(10), close.sma(20), delay=1, threshold=0.01) }

'buy' = { {close, sma(20)} | cross(threshold=0.01), {close, sma(10)} | cross(threshold=0.01) } | all | delay(1d)
'buy' = { close | cross(sma(10), type='rising', threshold=0.01), close | cross(sma(20), type='rising', threshold=0.01) } | all | open.delay(1d)
'buy' = { close | cross(sma(10), type='rising', threshold=0.01), close | cross(sma(20), type='rising', threshold=0.01) }.and | open.delay(1d)
'buy' = { close.rising(sma(10), threshold=0.01), close.rising(sma(20), threshold=0.01) }.and | open.delay(1d)
'buy' = { close >> sma(10), close >> sma(20) }.and | open.delay(1d)
'buy' = { (close >> sma(10)) and (close >> sma(20)) } | open.delay(1d)
'buy' = { close >> sma(10) and close >> sma(20) } | open.delay(1d)
'buy' = { close >> close.sma(10) and close >> close.sma(20) } @ open.delay(1d)
'buy' = { close >> sma(10) and close >> sma(20) } @ open.delay(1d)

# language definition
<definition>: <identifier> ':=' <expression>
<dataset>: <series> | <identifier>.<series_function> | <series> <operation> <function>
<expression>: <dataset> | <production> | <series> <operation> <series>
<function>: <identifier> | <identifier> <parameter_list> | <series_function>
<production>: <expression> '|' <expression>
<term>: <series> <operation> <series | function>
<series>: <identifier> | '{' <expression>, <expression>, ... '}'
<series_function>: sma | ema | delay | ... {<parameter_list>}


# 2. functional:
buy( any( cross(close, sma(20), delay=1, threshold=0.01), cross(sma(10), sma(20), delay=1, threshold=0.01) ))
signal('buy', any( cross(close, sma(20), delay=1, threshold=0.01), cross(sma(10), sma(20), delay=1, threshold=0.01) ))

# 3. piping:
{ cross(close, sma(20), delay=1, threshold=0.01), cross(sma(10), sma(20), delay=1, threshold=0.01) } | any | buy
{ cross(close, sma(20), delay=1, threshold=0.01), cross(sma(10), sma(20), delay=1, threshold=0.01) } | any | signal('buy')

{ {close, sma(20)} | cross(threshold=0.01), {close, sma(10)} | cross(threshold=0.01) } | any | signal('buy', delay=1d)
{ {close, sma(20)} | cross(threshold=0.01), {close, sma(10)} | cross(threshold=0.01) } | all | signal('buy', delay=1d)
{ {close, sma(20)} | cross(threshold=0.01), {close, sma(10)} | cross(threshold=0.01) } | all | delay(1d) | signal('buy')

# dataset
{ cross({close, sma(20)}, threshold=0.01), cross({close, sma(10)}, threshold=0.01) } | all | delay(1d) | signal('buy')
{ cross({close, sma(20)}, threshold=0.01), cross({close, sma(10)}, threshold=0.01) }.all | delay(1d) | signal('buy')
{ {close, sma(20)}.cross(threshold=0.01), {close, sma(10)}.cross(threshold=0.01) }.all | delay(1d) | signal('buy')
{ {close, close.sma(20)}.cross(threshold=0.01), {close, close.sma(10)}.5cross(threshold=0.01) }.all | delay(1d) | signal('buy')

# array
[ {close, sma(20)} | cross | threshold(0.01), {close, sma(10)} | cross | threshold(0.01) ] | all | delay(1d) | signal('buy')

# list
( {close, sma(20)} | cross | threshold(0.01), {close, sma(10)} | cross | threshold(0.01) ) | all | delay(1d) | signal('buy')

# equivalent
{close, sma(20)} | cross
(close, sma(20)) | cross
(close, close | sma(20)) | cross
(close, (close, 20) | sma) | cross

(close, close.sma(20)) | cross
cross.(close, close.sma(20))
cross(close, close.sma(20))
cross(close, sma(close, 20))

close.sma(10)
(close | sma(10))


(identifier)
buy: { {close, sma(20)} | cross(threshold=0.01), {close, sma(10)} | cross(threshold=0.01) } | all | delay(1d)
buy := { {close, sma(20)} | cross(threshold=0.01), {close, sma(10)} | cross(threshold=0.01) } | all | delay(1d)

{ {close, sma(20)} | cross(threshold=0.01), {close, sma(10)} | cross(threshold=0.01) } | or | signal('buy', delay=1d)
{ {close, sma(20)} | cross(threshold=0.01), {close, sma(10)} | cross(threshold=0.01) } | and | signal('buy', delay=1d)

{ {close, close | sma(20)} | cross(threshold=0.01), {close, close | sma(10)} | cross(threshold=0.01) } | and | signal('buy', delay=1d)

close.sma(20) | signal('buy', close, how='cross')   # makes 'signal' a *very* complex function with ever expanding set of 'how' sub-functions

close.sma(20) | signal(how='cross')
(close.sma(20) && close.sma(50)) | diff | sign | signal(how='cross')
buy = cross(close, sma(20)
close.sma(13) | signal(price, how='cross')
